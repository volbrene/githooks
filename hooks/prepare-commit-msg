#!/usr/bin/env bash
# prepare-commit-msg hook
# Auto-prefix commit messages based on branch name, but leave merge/squash/fixup etc. untouched.

set -euo pipefail

MSG_FILE="$1"
SOURCE="${2:-}"   # may be: message|template|merge|squash|commit|...

# --- EARLY EXITS: do not modify certain commit messages --------------------

# 1) Real merge commits (git passes "merge" as $2)
if [[ "$SOURCE" == "merge" ]]; then
  exit 0
fi

# 2) Squash commits (git passes "squash" as $2)
if [[ "$SOURCE" == "squash" ]]; then
  exit 0
fi

# 3) If message already starts with a Git-generated "Merge ..." header
#    This protects cases where $SOURCE is not provided (e.g. some tools/CI)
if grep -qE '^Merge (remote-tracking )?branch' "$MSG_FILE"; then
  exit 0
fi

# 3b) If message already starts with a Git-generated "Revert ..." header, keep it
if grep -qE '^Revert ' "$MSG_FILE"; then
  exit 0
fi

# 4) Respect fixup! and squash! messages (used for autosquash)
if grep -qE '^(fixup|squash)! ' "$MSG_FILE"; then
  exit 0
fi

# 5) If the message already has a valid Conventional Commit header, do nothing
if grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([^)]+\))?: ' "$MSG_FILE"; then
  exit 0
fi

# --- DETERMINE BRANCH AND BUILD MESSAGE -------------------------------------

RAW_BRANCH="$(git rev-parse --abbrev-ref HEAD)"

# Extract optional ticket ID anywhere in the branch name (supports unlimited digits)
TICKET_ID="$(echo "$RAW_BRANCH" | grep -oE '[A-Z]{2,10}-[0-9]+' | head -n1 || true)"

# Helper: build the commit message header with or without ticket ID
build_message() {
  local type="$1"
  local file="$2"
  local body
  body="$(cat "$file")"
  if [ -n "$TICKET_ID" ]; then
    echo "${type}(${TICKET_ID}): ${body}"
  else
    echo "${type}: ${body}"
  fi
}

# Map branch prefixes to Conventional Commit types
if [[ "$RAW_BRANCH" == feature/* || "$RAW_BRANCH" == feat/* ]]; then
  NEW_MESSAGE="$(build_message "feat" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == bug/* || "$RAW_BRANCH" == bugfix/* || "$RAW_BRANCH" == hotfix/* || "$RAW_BRANCH" == fix/* ]]; then
  NEW_MESSAGE="$(build_message "fix" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == docs/* ]]; then
  NEW_MESSAGE="$(build_message "docs" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == style/* ]]; then
  NEW_MESSAGE="$(build_message "style" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == refactor/* ]]; then
  NEW_MESSAGE="$(build_message "refactor" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == perf/* || "$RAW_BRANCH" == performance/* ]]; then
  NEW_MESSAGE="$(build_message "perf" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == test/* || "$RAW_BRANCH" == tests/* ]]; then
  NEW_MESSAGE="$(build_message "test" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == build/* ]]; then
  NEW_MESSAGE="$(build_message "build" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == ci/* ]]; then
  NEW_MESSAGE="$(build_message "ci" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == revert/* ]]; then
  NEW_MESSAGE="$(build_message "revert" "$MSG_FILE")"
elif [[ "$RAW_BRANCH" == chore/* || "$RAW_BRANCH" == task/* ]]; then
  NEW_MESSAGE="$(build_message "chore" "$MSG_FILE")"
else
  # Fallback: use chore if no known prefix is found
  NEW_MESSAGE="$(build_message "chore" "$MSG_FILE")"
fi

# Overwrite commit message file with new header + original body
echo "$NEW_MESSAGE" > "$MSG_FILE"